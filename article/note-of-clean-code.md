

1: 减少重复代码, 提高表达力, 提早构建简单抽象.
2: 漂亮的代码让编程语言像是专门为解决那个问题而存在. 



##第二章: 有意义的命名

### 名副其实
变量、函数或类的名称应该表示： 它为什么会存在， 他做什么事， 应该怎么用。 如果名称需要注释来补充， 那就不算是名副其实。

eg:    let fileAgeInDays: Int 

###做有意义的区分
废话都是冗余。Variable 一词永远不应当出现在变量名中。 Table一次永远不应当出现再表名中。NameString会比Name好吗？

###使用读的出来的名称 
Oc中及是驼峰命名法， 并尽量表达真正的意图。

###使用可搜索的名称

###避免使用编码

###避免思维映射
明确是王道

###类名
类名和对象名称应该是名词或者名词短语， 如：Customer、WikiPage、Account 和 AddressParser。避免使用Manager、Processor、Data 或 Info这样的类名。类名不应该是动词。

###方法名
方法名应当是动词或动词短语。 如：postPayment、deletePage或save.

###别扮可爱
宁可明确，毋为好玩

###每个概念用一个词
给每个抽象概念选一个词，并且一以贯之。（相同意义的类命名方法或其变量的命名方式应该相同）

###别用双关语
应尽力写出易于理解的代码。不要为了"保存一致"而表达非真的想表达的意思。应该要尽责写清楚平装书而不是学院派模式。

###使用解决方案领域的名称
大胆使用计算机科学的术语、算法名、模式名

###使用源自所涉问题领域的名称

###添加有意义的语境

###不要添加无意义的语境



##第三章 函数

###短小
函数的第一规则就是要短小，第二规则还是要更短小。

###只做一件事（单一职责）
函数应该做一件事。做好这件事。只做这一件事。

如果函数只是做了该函数同一抽象层上的步骤，则函数还是只做了一件事。编写函数毕竟是为了把大一些的概念拆分为另一抽象层上的一系列步骤。

要盘端函数是否不止做了一件事，可以看是否能再拆出一个函数， 该函数不止是单纯的重新诠释其实现。（另一个抽象层）

###每个函数一个抽象层级
自顶向下读代码：向下规则

###Switch语句 (p35)
写出短小的switch或者if-else很难。但可以用多态实现。

一般情况下的switch语句都会违反 单一职责和开放封闭原则。

解决办法是： 将switch语句埋入到抽象工厂底下

###使用描述性名称
函数越短小、功能越集中，就越便于取个好名字

但： 长而具有描述性的名称， 要比短而令人费解的名称好

###函数参数
最理想的参数数量是零其次是一，尽量避免三（参数多同时也不利于测试）

如果函数看起来需要两个、三个或三个以上参数，说明其中一些参数应该封装为类了。

###无副作用

###分割指令与询问 (及：修改和查询)
将：
func set(name: String) -> Bool {}
修改为： 
func canSetName(name: String) -> Bool {}
func set(name: String) {}

###使用异常替代返回错误码
    使用异常来替代错误码，新异常就可以从异常类派生出来，无需重新编译或重新部署（如果用枚举错误码，就需要）

###Don’t repeat yourself

###结构化编程
函数中的每个代码块都应该有一个入口一个出口。（意味着只有一个return语句，并且循环中不能有break或continue语句）



##第四章：注释
注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。

其实在迫不得已的情况下，不推荐使用注释。

不准确的注释要比没注释坏的多

###注释不能美化糟糕的代码



##第五章：格式

###格式的目的
代码格式关于沟通，而沟通是专业开发者的头等大事

###垂直格式

####向报纸学习

####概念间垂直方向上的间隔
*每行展现一个表达式或一个句子，每组代码行展示一条完整的思路。这些思路用空白行区隔开来。（将组用空白行进行区隔）

####垂直方向上的靠近
靠近的代码暗示了他们之间的紧密关系

####垂直距离
变量声明 应该在类或者方法的顶部或者更恰当的位置。

相关函数 若某个函数调用了另外一个，就应该把他们放到一起。而且调用者更可能的放在被调用着的上面

概念相关 概念相关的代码应该放到一起。相关性越强，彼此之间的距离就该越短。

####水平方向的区隔与靠近
如： = 号两边有空格等



##第六章：对象和数据结构

###数据抽象

隐藏实现关乎抽象！类并不是简单的用取值器和赋值器将其变量推向外间，而是暴露抽象接口

###数据、对象的反对称性
对象把数据隐藏于抽象之后，暴露操作数据的函数。数据结构暴露其数据，没有提供有意义的函数。

过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数。面向对象代码便于再不改动既有函数的情况下添加新类。

所以，对于面向对象较难的事，对于过程式代码却比较容易，反之亦然！

###得墨忒定律（Law of demeter）亦称为“最少知道原则（Principle of Least Knowledge）
模块不应了解它所操作 *对象* 的内部情节。 对象应该隐藏数据，暴露操作。 

准确的说，得墨汰定律认为，类 C 的方法 f 只应该调用一下对象的方法：

* C

* 由 f 创建的对象

* 作为参数传递给 f 的对象

* 由 C 实体变量持有的对象。

方法 不应 调用由任何函数返回的 对象 的方法。 也就是说， 函数返回的是一个基本结构体




